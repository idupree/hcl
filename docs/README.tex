% Created 2013-02-12 Tue 13:58
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{soul}
\usepackage{amssymb}
\usepackage{hyperref}


\title{README}
\author{Sam Auciello}
\date{12 February 2013}

\begin{document}

\maketitle

\setcounter{tocdepth}{3}
\tableofcontents
\vspace*{1cm}
\section{HOT COCOA LISP}
\label{sec-1}

  Hot Cocoa Lisp is a dialect of Lisp designed to be compiled into
  Javascript.  It has been said that Javascript is Scheme in C's
  clothes.  Hot Cocoa Lisp is an attempt to put it back in Schemes
  clothes.
\subsection{High Level Design Goals}
\label{sec-1.1}

\begin{itemize}
\item Provide a clean, intuitive interface to existing
     Javascript libraries/frameworks
\item Use the minimal syntax of Lisp
\item Retain the good features of Javascript
     (first-class functions with closures, Dynamic objects with prototypes,
     Object literals).
\item Fix the problems of Javascript.
     (Global variables, type coersion, etc.)
\item Provide some of the introspective power of Lisp (quoting, macros etc.)
\end{itemize}
   
\subsection{Syntax}
\label{sec-1.2}

   The syntax of Hot Cocoa Lisp is the same as that of Scheme with
   four exceptions:
\begin{itemize}
\item As in clojure the \emph{unquote} symbol is \emph{\~{}} instead of /,/.
\item The square bracket notation for Array literals from JavaScript
     may be used but the commas are optional.
     
\begin{verbatim}
      ;; HCL
      [1 2 3]
      // JavaScript
      [1, 2, 3]
\end{verbatim}

     
     It is translated by the parser to the equivalent \emph{(list 1 2 3)}.
\item The curly bracket notation for object literals from JavaScript
     may be used but the commas and colons are optional.
     
\begin{verbatim}
      ;; HCL
      {a 1 b 2}
      // JavaScript
      {a: 1, b: 2}
\end{verbatim}

     
     It is translated by the parser to the equivalent \emph{(object a 1 b 2)}.
\item As in Javascript \emph{.} can be used as an object access operator.
     It works precisely as it does in JavaScript.
     
\begin{verbatim}
      ;; HCL
      foo.bar
      // JavaScript
      foo.bar
\end{verbatim}

     
     It is translated by the parser to the equivalent \emph{(. foo bar)}.
     
     It is also possible to use a lisp expression for the object being
     accessed:
     
\begin{verbatim}
      ;; HCL
      (some expression returning an object).keyname
      // JavaScript
      some(expression, returning, an, object).keyname
\end{verbatim}

\end{itemize}
   
   Hot Cocoa Lisp can syntactically supports most of the literals from
   Javascript:
\begin{itemize}
\item \emph{undefined}, \emph{null}, \emph{true}, and \emph{false} work exactly as they do
     in JavaScript.
\item Numbers work just as they do in JavaScript.
\item Strings literals must use double quotes but otherwise function as
     they do in JavaScript.
\item Functions, objects, arrays, and regular expressions are defined
     by the built-in functions named \emph{\#}, \emph{object}, \emph{list}, and \emph{re}
     respectively.
\end{itemize}
\subsection{Semantics}
\label{sec-1.3}

   The basic logic for converting a lisp expression into compiled
   JavaScript is quite simple.  If the first element of the expression
   is a built-in function the compiler calls on internal logic to
   compile the expression, otherwise each element is recursively
   compiled and then output in the form \emph{elem1(elem2, elem3, etc)}.
   Most of the remaining semantic logic takes the form of built-in function
   definitions.

\subsubsection{nop}
\label{sec-1.3.1}

    Takes no arguments and returns undefined.
    
\begin{verbatim}
     ;; HCL
     (for ((var i 0) (< i 10) (++ i))
         (nop))
     // JavaScript
     for (var i = 0; i < 10; i++) { }
\end{verbatim}


\subsubsection{.}
\label{sec-1.3.2}

    Takes two or more arguments and does chained object access with
    keys that were known at program writing time.

\begin{verbatim}
     ;; HCL
     (. foo bar baz)
     ;; OR
     foo.bar.baz
     // JavaScript
     foo.bar.baz
\end{verbatim}


\subsubsection{get}
\label{sec-1.3.3}

    Takes exactly two arguments and does object/list access using a
    key that might not be known until run time.

\begin{verbatim}
     ;; HCL
     (get list 10)
     // JavaScript
     list\footnote{FOOTNOTE DEFINITION NOT FOUND: 10 }
\end{verbatim}

    
    \textbf{Synonyms:} \emph{nth}

\subsubsection{list}
\label{sec-1.3.4}

    Create and return a new JavaScript array containing the given
    arguments.

\begin{verbatim}
     ;; HCL
     (list 1 2 3)
     ;; OR
     [1 2 3]
     // JavaScript
     [1, 2, 3]
\end{verbatim}

    
    \textbf{Synonyms:} \emph{array}

\subsubsection{object}
\label{sec-1.3.5}

    Takes an even number of arguments which it interprets pairwise as
    key/value pairs for a new JavaScript object which it creates and
    returns.

\begin{verbatim}
     ;; HCL
     (object name "Sam" age 23)
     ;; OR
     { name "Sam" age 23 }
     // JavaScript
     {name: "Sam", age: 23}
\end{verbatim}

    
\subsubsection{inherit}
\label{sec-1.3.6}

    Takes a single argument and returns a new empty object that
    inherits prototypically fromt the argument.
    
\begin{verbatim}
     ;; HCL
     (def x { a 1 })
     (def y (inherit x))
     y.a ; 1
     // JavaScript
     var x = {a: 1};
     var y = Object.create(x);
     y.a // 1
\end{verbatim}


\subsubsection{if}
\label{sec-1.3.7}

    Takes three arguments and returns the second if the first is true
    and the third if the first is false.
    
\begin{verbatim}
     ;; HCL
     (if (= x 1) "one" "not one")
     // JavaScript
     ((x === 1) ? "one" : "not one")
\end{verbatim}


\subsubsection{when}
\label{sec-1.3.8}

    Takes two or more arguments and executes the expressions following
    the first argument if the first argument is true
    
\begin{verbatim}
     ;; HCL
     (when (= x 1) (console.log "x is one"))
     // JavaScript
     ((x === 1) && (function() { console.log("x is one"); })())
\end{verbatim}


\subsubsection{cond}
\label{sec-1.3.9}

    



\end{document}