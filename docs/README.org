* HOT COCOA LISP
  Hot Cocoa Lisp is a dialect of Lisp designed to be compiled into
  Javascript.  It has been said that Javascript is Scheme in C's
  clothes.  Hot Cocoa Lisp is an attempt to put it back in Schemes
  clothes.
** High Level Design Goals
   - Provide a clean, intuitive interface to existing
     Javascript libraries/frameworks
   - Use the minimal syntax of Lisp
   - Retain the good features of Javascript
     (first-class functions with closures, Dynamic objects with prototypes,
     Object literals).
   - Fix the problems of Javascript.
     (Global variables, type coersion, etc.)
   - Provide some of the introspective power of Lisp (quoting, macros etc.)
   
** Syntax
   The syntax of Hot Cocoa Lisp is the same as that of Scheme with
   four exceptions:
   - As in clojure the /unquote/ symbol is /~/ instead of /,/.
   - The square bracket notation for Array literals from JavaScript
     may be used but the commas are optional.
     
     : ;; HCL
     : [1 2 3]
     : // JavaScript
     : [1, 2, 3]
     
     It is translated by the parser to the equivalent /(list 1 2 3)/.
     
   - The curly bracket notation for object literals from JavaScript
     may be used but the commas and colons are optional.
     
     : ;; HCL
     : {a 1 b 2}
     : // JavaScript
     : {a: 1, b: 2}
     
     It is translated by the parser to the equivalent /(object a 1 b 2)/.     
     
   - As in Javascript /./ can be used as an infix object access
     operator.  It works precisely as it does in JavaScript.
     
     : ;; HCL
     : foo.bar
     : // JavaScript
     : foo.bar
     
     It is translated by the parser to the equivalent /(. foo bar)/.
     
     It is also possible to use a lisp expression for the object being
     accessed:
     
     : ;; HCL
     : (some expression returning an object).keyname
     : // JavaScript
     : some(expression, returning, an, object).keyname
   
   Hot Cocoa Lisp can syntactically supports most of the literals from
   Javascript:
   - /undefined/, /null/, /true/, and /false/ work exactly as they do
     in JavaScript.
   - Numbers work just as they do in JavaScript.
   - Strings literals must use double quotes but otherwise function as
     they do in JavaScript.
   - Functions, objects, arrays, and regular expressions are defined
     by the built-in functions named /#/, /object/, /list/, and /re/
     respectively.

** Semantics
   The basic logic for converting a lisp expression into compiled
   JavaScript is quite simple.  If the first element of the expression
   is a built-in function the compiler calls on internal logic to
   compile the expression, otherwise each element is recursively
   compiled and then output in the form /elem1(elem2, elem3, etc)/.
   Most of the remaining semantic logic takes the form of built-in function
   definitions.

*** nop
    Takes no arguments and returns undefined.
    
    : ;; HCL
    : (for ((var i 0) (< i 10) (++ i))
    :     (nop))
    : // JavaScript
    : for (var i = 0; i < 10; i++) { }

*** .
    Takes two or more arguments and does chained object access with
    keys that were known at program writing time.

    : ;; HCL
    : (. foo bar baz)
    : ;; OR
    : foo.bar.baz
    : // JavaScript
    : foo.bar.baz

*** get
    Takes exactly two arguments and does object/list access using a
    key that might not be known until run time.

    : ;; HCL
    : (get list 10)
    : // JavaScript
    : list[10]
    
    *Synonyms:* /nth/

*** list
    Create and return a new JavaScript array containing the given
    arguments.

    : ;; HCL
    : (list 1 2 3)
    : ;; OR
    : [1 2 3]
    : // JavaScript
    : [1, 2, 3]
    
    *Synonyms:* /array/

*** object
    Takes an even number of arguments which it interprets pairwise as
    key/value pairs for a new JavaScript object which it creates and
    returns.

    : ;; HCL
    : (object name "Sam" age 23)
    : ;; OR
    : { name "Sam" age 23 }
    : // JavaScript
    : {name: "Sam", age: 23}
    
*** inherit
    Takes a single argument and returns a new empty object that
    inherits prototypically from the argument.
    
    : ;; HCL
    : (def x { a 1 })
    : (def y (inherit x))
    : y.a ; 1
    : // JavaScript
    : var x = {a: 1};
    : var y = Object.create(x);
    : y.a // 1

*** begin
    Equivalent to /progn/ in Common Lisp.  It simply evaluates all of
    it's arguments and returns the last one.
    
    : ;; HCL
    : (if (condition)
    :     (begin
    :        (thing one)
    :        (thing two)
    :   (other thing)))
    : // JavaScript
    : if (condition) {
    :   thing(one);
    :   thing(two);
    : } else {
    :   other(thing);
    : }
    
*** if
    Takes three arguments and returns the second if the first is true
    and the third if the first is false.
    
    : ;; HCL
    : (if (= x 1) "one" "not one")
    : // JavaScript
    : ((x === 1) ? "one" : "not one")

*** when
    Takes two or more arguments and executes the expressions following
    the first argument if the first argument is true
    
    : ;; HCL
    : (when (= x 1) (console.log "x is one"))
    : // JavaScript
    : ((x === 1) && (function() { console.log("x is one"); })())

*** cond
    Checks the first element of each argument until it finds one that
    evaluates to true and returns the second element of that
    argument.  Returns /undefined/ if nonde is found.
    
    : ;; HCL
    : (cond
    :  ((= x 1) 7)
    :  ((= y 2) 8)
    :  (true 9))
    : // JavaScript
    : (x === 1) ? 7 : (y === 2) ? 8 : 9

*** while
    Evaluates each of it's arguments in a loop until the first
    evalutes to false.
    
    : ;; HCL
    : (while true
    :    (do this forever)
    :    (and this))
    : // JavaScript
    : while (true) {
    :   do(this, forever);
    :   and(this);
    : }
    
*** for
    The first argument is a list of either two of three elements
    defining the loop.  If there are two elements then the loop
    function like a python for loop with the for argument being an
    iteration variable and the second being a list (or any other
    object with a length property).
    
    : ;; HCL
    : (for (x list)
    :    (print x))
    : // JavaScript
    : for (var i = 0; i < list.length; i++) {
    :   var x = list[i];
    :   print(x);
    : }
    
    If there are three elements in the first argument then the loop
    functions like a JavaScript or C for loop with the first element
    being evaluated once at the beginning, the second being evaluated
    at the beginning of each pass throught the loop to determine if
    the loop should continue, and the third being called after each
    pass through the loop.
    
    : ;; HCL
    : (for ((var node linked-list) (not (nil? node)) (set node node.next))
    :    (print node.value))
    : // JavaScript
    : for (var node = linked_list; node !== undefined ; node = node.next) {
    :   print(node.value);
    : }
    
*** times
    The first argument of the list should contain two elements; the
    first an iteration variable and the second a number.  The loop
    executes the specified number of times each time setting the
    variable to the number corresponding to the interation (starting
    with 0).
    
    : ;; HCL
    : (times (x 10)
    :   (print x))
    : // JavaScript
    : for (var x = 0; x < 10; x++) {
    :   print(x);
    : }

*** error
    Takes a string and throws a JavaScript exception with the
    specified message.
    
    : ;; HCL
    : (error "This shouldn't be happening")
    : // JavaScript
    : throw new Error("This shouldn't be happening");
    
    *Synonyms:* /throw/
    
*** attempt
    Encloses a try/catch/finally block.  The first argument should be
    a list beginning with the symbol "try" and whos remaining
    arguments will be executed in the try block.  The second argument
    may either be a list beginning with "catch" or a list beginning
    with "finally" and in the former case there can be a third
    argument beginning with "finally".  The second element of a catch
    block should be a variable to store the caught error in.
    
    : ;; HCL
    : (attempt
    :   (try
    :     (open a file)
    :     (code that may fail))
    :   (catch e
    :     (console.log "An error occured: " e))
    :   (finally (close the file)))
    : // JavaScript
    : try {
    :   open(a, file);
    :   code(that, may, fail);
    : } catch (e) {
    :   console.log("An error occured: ", e);
    : } finally {
    :   close(the, file);
    : }
    
*** +
    Adds all of the arguments together.
    
    : ;; HCL
    : (+ 1 2 3)
    : // JavaScript
    : (1 + 2 + 3)
    
    *Synonyms:* /cat/
    
*** +1
    Shorthand to returns the specified number plus 1.
    
    : ;; HCL
    : (+1 2)
    : // JavaScript
    : (1 + 2)

*** -, *, /
    The familiar arithmentic operations work just like "+" except
    that - can take a single argument and return it's opposite.
    
    : ;; HCL
    : (+ 1 (* 3 (/ 12 6)))
    : // JavaScript
    : (1 + (3 * (12 / 6)))

*** -1, *2, /2
    Shorthand for subtract 1, double, or half respecitvely.
    
    : ;; HCL
    : (*2 (-1 (/2 8)))
    : // JavaScript
    : (((8 / 2) - 1) * 2)
    
    *Synonyms:* *\*2*: /double/, */2*: /half/

*** ^
    Returns the first argument to the power of the second.
    
    : ;; HCL
    : (^ 2 n)
    : // JavaScript
    : Math.pow(2, n);
    
*** ^2
    Shorthand for square.
    
    : ;; HCL
    : (^2 17)
    : // JavaScript
    : (17 * 17)
    
    *Synonyms:* /square/
    
*** sqrt
    Take the square root of the number.
    
*** %
    Returns the remainder produced when dividing the first argument by
    the second.
    
    *Synonyms:* /mod/

*** <, >, <=, >=, =, !=
    The familiar comparison operators.
    
    *Synonyms:* *<*: /lt?/, *>*: /gt?/, *<=*: /lte?/, *>=*: /gte?/,
    *=*: /eq?/, /is?/, *!=*: /neq?/, /isnt?/ 
    
*** =0
    Shorthand 
